<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Sorghum Reconstruction and Phenotyping: lsystemFitting.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sorghum Reconstruction and Phenotyping
   &#160;<span id="projectnumber">0.02</span>
   </div>
   <div id="projectbrief">Image-based plant phenotyping</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lsystemFitting.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;pcl/visualization/pcl_visualizer.h&gt;</code><br/>
<code>#include &lt;pcl/io/pcd_io.h&gt;</code><br/>
<code>#include &lt;pcl/io/ply_io.h&gt;</code><br/>
<code>#include &lt;pcl/common/common.h&gt;</code><br/>
<code>#include &lt;pcl/common/pca.h&gt;</code><br/>
<code>#include &lt;pcl/filters/passthrough.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/ransac.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/method_types.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/model_types.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_cylinder.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_plane.h&gt;</code><br/>
<code>#include &lt;pcl/ModelCoefficients.h&gt;</code><br/>
<code>#include &lt;pcl/segmentation/sac_segmentation.h&gt;</code><br/>
<code>#include &lt;pcl/filters/extract_indices.h&gt;</code><br/>
<code>#include &lt;pcl/features/normal_3d_omp.h&gt;</code><br/>
<code>#include &lt;pcl/kdtree/kdtree_flann.h&gt;</code><br/>
<code>#include &lt;python2.7/Python.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="loggingHelper_8h_source.html">loggingHelper.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="boundingBox_8h_source.html">boundingBox.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lsystemFitting_8h_source.html">lsystemFitting.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lsystemParameters_8h_source.html">lsystemParameters.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sampleMeshToPointCloud_8h_source.html">sampleMeshToPointCloud.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="IterativeClosestPoint_8h_source.html">IterativeClosestPoint.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="utilityFunctions_8h_source.html">utilityFunctions.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lsystemRefinement_8h_source.html">lsystemRefinement.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5f4d1870e38b06476f8656b1b4c761a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a5f4d1870e38b06476f8656b1b4c761a2">identifyCylinderCloudsBasedOnStemModel</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr originalCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputInnerCylinderPoints, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputOuterCylinderPointsExcludingInnerCylinder, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputOuterCylinderPoints, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputOutsideOuterCylinderPoints, Eigen::VectorXf cylinderCoefficients, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a5f4d1870e38b06476f8656b1b4c761a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3c1259ed1656d1cb71b6ff478128c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#add3c1259ed1656d1cb71b6ff478128c0">identifyPointsOfEmergingLeaves</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputStemCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputPutativeLeafPoints, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputLeafPoints, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:add3c1259ed1656d1cb71b6ff478128c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7138e4cb7818a013faee7e2bcc29ff"><td class="memItemLeft" align="right" valign="top">Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a0a7138e4cb7818a013faee7e2bcc29ff">findPlaneToBisectStem</a> (Eigen::Matrix3f inputLeafPCAEigenVectors, Eigen::Vector3f inputLeafPCAEigenValues, pcl::PointXYZ inputOriginPoint, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr nonCylinderPoints, Eigen::VectorXf inputCylinderCoefficients, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a0a7138e4cb7818a013faee7e2bcc29ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2481790b11cc6929b6d8c143192ac2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#abb2481790b11cc6929b6d8c143192ac2">fitLSystemToPointCloud</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:abb2481790b11cc6929b6d8c143192ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad1c875ec627e3d8bede7a8d737101d"><td class="memItemLeft" align="right" valign="top">pcl::PolygonMesh&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a5ad1c875ec627e3d8bede7a8d737101d">buildLSystem</a> (PyObject *inputLpyFunction, <a class="el" href="classLSystemParameters.html">LSystemParameters</a> inputLSystemParams, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a5ad1c875ec627e3d8bede7a8d737101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d45d0986cfb2541c45d867e3484b22"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a55d45d0986cfb2541c45d867e3484b22">returnTurnAndPitchAnglesToMoveZAxisToNormal</a> (Eigen::Vector3f vInputNormal, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a55d45d0986cfb2541c45d867e3484b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1010a1f57a311aa425438f8b0321db"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a8f1010a1f57a311aa425438f8b0321db">returnLeafPhyllotaxyAngleToMoveXAxisToNormal</a> (Eigen::Vector3f vInputCylinderAxisNormal, Eigen::Vector3f vInputPlaneNormal, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a8f1010a1f57a311aa425438f8b0321db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe617b8fa310a722050c652e0de5ff2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#aafe617b8fa310a722050c652e0de5ff2">returnSecondLeafCurvatureControlPointEstimate</a> (pcl::PointXYZ inputLeafPointOrigin, pcl::PointXYZ inputLeafPointEnd, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:aafe617b8fa310a722050c652e0de5ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9432daeaca6de6906417422e6eb3c353"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#a9432daeaca6de6906417422e6eb3c353">fitLSystemToPointCloudv2</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a9432daeaca6de6906417422e6eb3c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76041a749f4a77a1229fdf7bf806b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsystemFitting_8cpp.html#ac76041a749f4a77a1229fdf7bf806b5c">fitLSystemToPointCloudv1</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:ac76041a749f4a77a1229fdf7bf806b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5ad1c875ec627e3d8bede7a8d737101d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PolygonMesh buildLSystem </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>inputLpyFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLSystemParameters.html">LSystemParameters</a>&#160;</td>
          <td class="paramname"><em>inputLSystemParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a7138e4cb7818a013faee7e2bcc29ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector4f findPlaneToBisectStem </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix3f&#160;</td>
          <td class="paramname"><em>inputLeafPCAEigenVectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>inputLeafPCAEigenValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointXYZ&#160;</td>
          <td class="paramname"><em>inputOriginPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>nonCylinderPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf&#160;</td>
          <td class="paramname"><em>inputCylinderCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I think the trick will be to find the plane that contains both the plane normal vector and the cylinder vector. Then we can drop the vector of the plane normal to be 90 degrees relative to the cylinder vector using that plane.</p>
<p>In some cases, this can be misleading if the second principal component is leaf width as opposed to leaf length. To try to resolve cases where leaf width mistakenly gets used. If the leaf width dimension gets mistakenly used, a large proportion of the points on either side of the plane will be adjacent to each other. If this is the case, I think we can swap the x and y of the principal component for the plane and try again.</p>
<p>IMPORTANT MAGIC NUMBER HERE, CONSIDER REFACTORING TO INPUT VARIABLE IF THIS METHOD IS USED. This number determines the radius away from the stem points that putative leaf points will be considered neighbors. </p>

</div>
</div>
<a class="anchor" id="abb2481790b11cc6929b6d8c143192ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fitLSystemToPointCloud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the necessary elements for embedded python.</p>
<p>Finished loading elements for embedded python.</p>
<p>Set up the visualizer for viewing.</p>
<p>Finished setting up the visualizer for viewing.</p>
<p>As a first attempt, we'll move from the bottom, up and fit single phytomer L-systems to the cloud. I think the best way to do this will be to fit a cylinder the the very bottom of the plant (i.e., no leaves) and keep moving up incrementally until a large number of points don't fit with the cylinder (i.e., a leaf is found).</p>
<p>Assumptions: Plant stem is reasonably well aligned with the Z axis (oriented via pot segmentation)</p>
<p>First, get a short portion of the bottom stem (pass through filter) and find a cylinder that fits it (RANSAC).</p>
<p>To get a short portion of the bottom stem, we've move 5% up from the bottom to the top along the z axis.</p>
<p>Now, find a cylinder that fits those points. RANSAC of stem to find radius. Let's consider modifying this to find multiple stem layers up the stem instead of one large cylinder.</p>
<p>So we have a starting cylindrical model (i.e., cylinder radius for the lsystem). Can we iteratively move up the stem until the points outside of it become significant? Let's work with a donut model, where the "hole" is the stem, and points within a second radius can be considered leaves.</p>
<p>Here's the important logic loop for constructing the L-System.</p>
<p>If we've found a set of points that don't belong to the stem, it's likely a leaf emerging. We can probably save the internode height and radius here. Then we can figure out the orientation that the leaf is emerging.</p>
<p>One common error is that leaf points not accounted for are present in the next layer up (due to angle and curvature). I think we can correct for those by only considering points that are adjacent to stem points for adding a phytomer, that is, only consider points that might be from leaf emerging from the stem, rather than points that might be from a leaf from a phytomer below that are far away from the stem.</p>
<p>I think one way to do this, since we expect ~ 180 degree phyllotaxy, is to bisect the stem to isolate a leaf (if more than one leaf are appearing), then use orientation of the principal component of the leaf points to orient the L system. I think we can use the axis of the cylinder as one dimension for the plane, then find the principal component of non cylinder points and use an orthogonal normal that is most orthogonal to the cylinder axis.</p>
<p>Try to draw a line that starts halway in the layer z interval and centered at the cylinder center, pointing in the direction of the first principal component. <a href="http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line">http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line</a></p>
<p>Find a plane that bisects the stem to try and partition the leaf points to one half of the plant. This is to correctly generate two phytomers if the layer contains two leaves. Plane model parameters contains the x, y, and z of the plane equation in indices 0, 1, and 2. Index 3 contains the intercept.</p>
<p>I think we pretty much have to do everything above again, but once for each set of points if two significant sets of points are found.</p>
<p>Try to draw a line that starts halway in the layer z interval and centered at the cylinder center, pointing in the direction of the first principal component. <a href="http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line">http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line</a></p>
<p>Maybe what we really want is to use the x and the y of the leaf projection, and fix the z to find a plane.</p>
<p>Now I think we have enough data to build a rough L-system. We have estimations of: how tall the internode is. the radius of the internode. the phyllotaxy of the leaf with respect to the internode. the angle of emergence of the leaf with respect to the internode. Now let's build an L-system from that.</p>
<p>Internode lengths. Each phytomer will be different.</p>
<p>Internode radii. Both phytomers will be equivalent.</p>
<p>Stem turn and pitch. The second phytomer will be 0, 0</p>
<p>Leaf widths. Set to the same as a default for now.</p>
<p>Leaf phyllotaxy angle.</p>
<p>Leaf curvature.</p>
<p>Process normal side first.</p>
<p>Internode lengths.</p>
<p>Internode radii. Both phytomers will be equivalent.</p>
<p>Stem turn and pitch. The second phytomer will be 0, 0</p>
<p>Leaf widths. Set to the same as a default for now.</p>
<p>Leaf phyllotaxy angle.</p>
<p>Leaf curvature.</p>
<p>Internode lengths.</p>
<p>Internode radii.</p>
<p>Stem turn and pitch.</p>
<p>Leaf widths.</p>
<p>Leaf phyllotaxy angle.</p>
<p>Leaf curvature.</p>
<p>04/26/16 Resume from here; work on making sure the cylinder gets identified correctly. Derivation 4 appears to be having problems.</p>
<p>To fast forward when testing things, can set up a fixed L-System here.</p>
<p>Now we need to get a point cloud sampled from the mesh of the L-system to create what a point cloud generated from that L-system might look like.</p>
<p>Now I guess we can fit this L-system and make minor refinements to things like internode height, leaf phyllotaxy, and the first two control points (really, only the second control point since the first is always (0, 0). I don't think we'd want to refine either of the other two control points since we might not have the full leaf yet.</p>
<p>This will allow us to assign points as accounted for or not by the L-System. Iterative closest point seems as good as anything else for the time being, though really we should be able to just transform the Lsystem to the RANSAC cylinder of the stem and get pretty close?</p>
<p>IMPORTANT MAGIC NUMBER HERE, CONSIDER REFACTORING TO INPUT VARIABLE IF THIS METHOD IS USED. This number determines the radius away from the L-System points that points in the original cloud will be considered accounted for in the L-system. </p>

</div>
</div>
<a class="anchor" id="ac76041a749f4a77a1229fdf7bf806b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fitLSystemToPointCloudv1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As a first attempt, we'll move from the bottom, up and fit single phytomer L-systems to the cloud. I think the best way to do this will be to fit a cylinder the the very bottom of the plant (i.e., no leaves) and keep moving up incrementally until a large number of points don't fit with the cylinder (i.e., a leaf is found).</p>
<p>Assumptions: Plant stem is reasonably well aligned with the Z axis (oriented via pot segmentation)</p>
<p>First, get a short portion of the bottom stem (pass through filter) and find a cylinder that fits it (RANSAC).</p>
<p>To get a short portion of the bottom stem, we've move 5% up from the bottom to the top along the z axis.</p>
<p>Now, find a cylinder that fits those points. RANSAC of stem to find radius. Let's consider modifying this to find multiple stem layers up the stem instead of one large cylinder.</p>
<p>So we have a vague cylindrical model (i.e., cylinder radius for the lsystem). Can we iteratively move up the stem until the points outside of it become significant?</p>
<p>If we've found a set of points that don't belong to the stem, it's likely a leaf emerging. We can probably save the internode height and radius here. Then we can figure out the orientation that the leaf is emerging.</p>
<p>I think one way to do this, since we expect ~ 180 degree phyllotaxy, is to bisect the stem to isolate a leaf (if more than one leaf are appearing), then use orientation of the principal component of the leaf points to orient the L system. I think we can use the axis of the cylinder as one dimension for the plane, then find the principal component of non cylinder points and use an orthogonal normal that is most orthogonal to the cylinder axis.</p>
<p>Try to draw a line that starts halway in the layer z interval and centered at the cylinder center, pointing in the direction of the first principal component. <a href="http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line">http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line</a></p>
<p>So we should have a rough orientation of the leaf. Now we want to bisect the stem. I think we can do this by ignoring the z dimension, and finding a line that is orthogonal to the leaf orientation.</p>
<p>Maybe instead of an orthogonal rotation, one way to go is to just rotate it by 90 around one of the axes.</p>
<p>Maybe what we really want is to use the x and the y of the leaf projection, and fix the z to find a plane.</p>
<p>With the rotated line, we use it as the basis of a plane to bisect the points. All points that are one one side belong to a new leaf point cloud. </p>

</div>
</div>
<a class="anchor" id="a9432daeaca6de6906417422e6eb3c353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fitLSystemToPointCloudv2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the necessary elements for embedded python.</p>
<p>Finished loading elements for embedded python.</p>
<p>As a first attempt, we'll move from the bottom, up and fit single phytomer L-systems to the cloud. I think the best way to do this will be to fit a cylinder the the very bottom of the plant (i.e., no leaves) and keep moving up incrementally until a large number of points don't fit with the cylinder (i.e., a leaf is found).</p>
<p>Assumptions: Plant stem is reasonably well aligned with the Z axis (oriented via pot segmentation)</p>
<p>First, get a short portion of the bottom stem (pass through filter) and find a cylinder that fits it (RANSAC).</p>
<p>To get a short portion of the bottom stem, we've move 5% up from the bottom to the top along the z axis.</p>
<p>Now, find a cylinder that fits those points. RANSAC of stem to find radius. Let's consider modifying this to find multiple stem layers up the stem instead of one large cylinder.</p>
<p>So we have a vague cylindrical model (i.e., cylinder radius for the lsystem). Can we iteratively move up the stem until the points outside of it become significant?</p>
<p>If we've found a set of points that don't belong to the stem, it's likely a leaf emerging. We can probably save the internode height and radius here. Then we can figure out the orientation that the leaf is emerging.</p>
<p>I think one way to do this, since we expect ~ 180 degree phyllotaxy, is to bisect the stem to isolate a leaf (if more than one leaf are appearing), then use orientation of the principal component of the leaf points to orient the L system. I think we can use the axis of the cylinder as one dimension for the plane, then find the principal component of non cylinder points and use an orthogonal normal that is most orthogonal to the cylinder axis.</p>
<p>Try to draw a line that starts halway in the layer z interval and centered at the cylinder center, pointing in the direction of the first principal component. <a href="http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line">http://math.stackexchange.com/questions/404440/what-is-the-formula-for-a-3d-line</a></p>
<p>Maybe what we really want is to use the x and the y of the leaf projection, and fix the z to find a plane.</p>
<p>With the rotated line, we use it as the basis of a plane to bisect the points. All points that are one one side belong to a new leaf point cloud.</p>
<p>Now I think we have enough data to build a rough L-system. We have estimations of: how tall the internode is. the radius of the internode. the phyllotaxy of the leaf with respect to the internode. the angle of emergence of the leaf with respect to the internode. Now let's build an L-system from that.</p>
<p>Now we need to get a point cloud sampled from the mesh of the L-system to create what a point cloud generated from that L-system might look like.</p>
<p>Now I guess we can fit this L-system and make minor refinements to things like internode height, leaf phyllotaxy, and the first two control points (really, only the second control point since the first is always (0, 0). I don't think we'd want to refine either of the other two control points since we might not have the full leaf yet.</p>
<p>This will allow us to assign points as accounted for or not by the L-System. Iterative closest point seems as good as anything else for the time being, though really we should be able to just transform the Lsystem to the RANSAC cylinder of the stem and get pretty close?</p>
<p>At this point, I think we'll have a decent L-system for the first phytomer. The next step is to move up one and add a phytomer, taking into consideration the current L-system and the points that remain after fitting it. </p>

</div>
</div>
<a class="anchor" id="a5f4d1870e38b06476f8656b1b4c761a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int identifyCylinderCloudsBasedOnStemModel </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>originalCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputInnerCylinderPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputOuterCylinderPointsExcludingInnerCylinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputOuterCylinderPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputOutsideOuterCylinderPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf&#160;</td>
          <td class="paramname"><em>cylinderCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I think the easiest approach will be to transform the cylinder to the z axis, and then find if a point is within the X,Y circle.</p>
<p>IMPORTANT MAGIC NUMBERS HERE, CONSIDER REFACTORING TO INPUT VARIABLE IF THIS METHOD IS USED. The inner radius number determines a scaling factor of how much the inner cylinder will be expanded. The outer radius number determines a scaling factor of how much the outer radius will be expanded relative to the inner radius. </p>

</div>
</div>
<a class="anchor" id="add3c1259ed1656d1cb71b6ff478128c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int identifyPointsOfEmergingLeaves </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputStemCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputPutativeLeafPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputLeafPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IMPORTANT MAGIC NUMBER HERE, CONSIDER REFACTORING TO INPUT VARIABLE IF THIS METHOD IS USED. This number determines the radius away from the stem points that putative leaf points will be considered neighbors. </p>

</div>
</div>
<a class="anchor" id="a8f1010a1f57a311aa425438f8b0321db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float returnLeafPhyllotaxyAngleToMoveXAxisToNormal </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>vInputCylinderAxisNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>vInputPlaneNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is also a mess; for now we just find phyllotaxy based on the normal of the plane for the leaf. For the leaf phyllotaxy angle, I suppose we can align the cylinder to the z axis, use the rotation matrix from that alignment, apply it to the leaf plane normal, then find the angle between the leaf plane normal and the x axis, and use that as the leaf phyllotaxy angle. This doesn't seem to work in application since we don't have any guarantee where the plane axis will end up. It can be fixed once a better solution is identified. and by better solution, one that keeps the L system as close of a transformation as possible to the original cloud (ideally just a translation). </p>
<p>This line pretty much overrides everything above with respect to finding the rotated plane. It can be removed once a better solution is identified. and by better solution, one that keeps the L system as close of a transformation as possible to the original cloud (ideally just a translation). </p>

</div>
</div>
<a class="anchor" id="aafe617b8fa310a722050c652e0de5ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;float, float&gt; returnSecondLeafCurvatureControlPointEstimate </td>
          <td>(</td>
          <td class="paramtype">pcl::PointXYZ&#160;</td>
          <td class="paramname"><em>inputLeafPointOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointXYZ&#160;</td>
          <td class="paramname"><em>inputLeafPointEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55d45d0986cfb2541c45d867e3484b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;float, float&gt; returnTurnAndPitchAnglesToMoveZAxisToNormal </td>
          <td>(</td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>vInputNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is currently a mess and needs to be cleaned up. The mess is mostly a consequence of my lack of understanding regarding vector rotations. The clutter will be kept until enough test cases have been run to be convincing that this generally works. </p>
<p>These unit vectors can be used to test calculations.</p>
<p>We need to find one rotation first, then the second since it's dependent on the first. Rotation matrix about the x axis: <a href="https://en.wikipedia.org/wiki/Rotation_matrix">https://en.wikipedia.org/wiki/Rotation_matrix</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2016 10:28:18 for Sorghum Reconstruction and Phenotyping by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
