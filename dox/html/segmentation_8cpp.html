<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Sorghum Reconstruction and Phenotyping: segmentation.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sorghum Reconstruction and Phenotyping
   &#160;<span id="projectnumber">0.02</span>
   </div>
   <div id="projectbrief">Image-based plant phenotyping</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">segmentation.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;unordered_map&gt;</code><br/>
<code>#include &lt;map&gt;</code><br/>
<code>#include &lt;tuple&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;pcl/point_cloud.h&gt;</code><br/>
<code>#include &lt;pcl/point_types.h&gt;</code><br/>
<code>#include &lt;pcl/conversions.h&gt;</code><br/>
<code>#include &lt;pcl/common/pca.h&gt;</code><br/>
<code>#include &lt;pcl/io/pcd_io.h&gt;</code><br/>
<code>#include &lt;pcl/io/ply_io.h&gt;</code><br/>
<code>#include &lt;pcl/visualization/pcl_visualizer.h&gt;</code><br/>
<code>#include &lt;pcl/filters/extract_indices.h&gt;</code><br/>
<code>#include &lt;pcl/filters/voxel_grid.h&gt;</code><br/>
<code>#include &lt;pcl/filters/statistical_outlier_removal.h&gt;</code><br/>
<code>#include &lt;pcl/filters/passthrough.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/ransac.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/method_types.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/model_types.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_circle3d.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_cylinder.h&gt;</code><br/>
<code>#include &lt;pcl/sample_consensus/sac_model_plane.h&gt;</code><br/>
<code>#include &lt;pcl/ModelCoefficients.h&gt;</code><br/>
<code>#include &lt;pcl/segmentation/sac_segmentation.h&gt;</code><br/>
<code>#include &lt;pcl/segmentation/region_growing.h&gt;</code><br/>
<code>#include &lt;pcl/features/normal_3d.h&gt;</code><br/>
<code>#include &lt;pcl/features/normal_3d_omp.h&gt;</code><br/>
<code>#include &lt;pcl/segmentation/extract_clusters.h&gt;</code><br/>
<code>#include &lt;pcl/segmentation/supervoxel_clustering.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="boundingBox_8h_source.html">boundingBox.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tupleTriplet_8h_source.html">tupleTriplet.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="visualizer__helper_8h_source.html">visualizer_helper.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="supervoxel__construction_8h_source.html">supervoxel_construction.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="plantSegmentationDataContainer_8h_source.html">plantSegmentationDataContainer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="segmentation_8h_source.html">segmentation.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dijkstraPathfinding_8h_source.html">dijkstraPathfinding.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="inputParams_8h_source.html">inputParams.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="loggingHelper_8h_source.html">loggingHelper.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:addedd5f094ff6a9309d30e396aa0514b"><td class="memItemLeft" align="right" valign="top">typedef pcl::PointNormal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#addedd5f094ff6a9309d30e396aa0514b">PointNT</a></td></tr>
<tr class="separator:addedd5f094ff6a9309d30e396aa0514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782f78115ae6b3e2449e6775607a98b"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
pcl::visualization::PointCloudColorHandlerCustom<br class="typebreak"/>
&lt; pcl::PointXYZ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a2782f78115ae6b3e2449e6775607a98b">ColorHandlerXYZ</a></td></tr>
<tr class="separator:a2782f78115ae6b3e2449e6775607a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a065c9a2e6dc92a1da2023ab564420"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
pcl::visualization::PointCloudColorHandlerCustom<br class="typebreak"/>
&lt; <a class="el" href="features_8cpp.html#addedd5f094ff6a9309d30e396aa0514b">PointNT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#ab5a065c9a2e6dc92a1da2023ab564420">ColorHandlerNT</a></td></tr>
<tr class="separator:ab5a065c9a2e6dc92a1da2023ab564420"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fc377dbdd139bb18dd2c64d8815cf51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a0fc377dbdd139bb18dd2c64d8815cf51">pointsXYZareEqual</a> (pcl::PointXYZ point1, pcl::PointXYZ point2)</td></tr>
<tr class="separator:a0fc377dbdd139bb18dd2c64d8815cf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33d29c6a70009528ccfc7eca55b2938"><td class="memItemLeft" align="right" valign="top">pcl::PolygonMesh&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#aa33d29c6a70009528ccfc7eca55b2938">extractMeshFromPolygonMeshGivenPointCloud</a> (pcl::PolygonMesh inputMesh, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr segmentedCloud)</td></tr>
<tr class="separator:aa33d29c6a70009528ccfc7eca55b2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9b302edc2b330924a76979500c03eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#acb9b302edc2b330924a76979500c03eb">segmentStemWithRANSAC</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr cloudPoints, pcl::PointCloud&lt; pcl::Normal &gt;::Ptr cloudNormals, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:acb9b302edc2b330924a76979500c03eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d61e15fa03f8db8dea9f671ab7c9ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a3d61e15fa03f8db8dea9f671ab7c9ff9">segmentFromLearnedPoints</a> (int argc, char **argv, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr cloudPoints, pcl::PointCloud&lt; pcl::Normal &gt;::Ptr cloudNormals, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams, pcl::visualization::PCLVisualizer *visualizer, int viewport)</td></tr>
<tr class="memdesc:a3d61e15fa03f8db8dea9f671ab7c9ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code to segment mesh points based on assignments made during machine learning.  <a href="#a3d61e15fa03f8db8dea9f671ab7c9ff9">More...</a><br/></td></tr>
<tr class="separator:a3d61e15fa03f8db8dea9f671ab7c9ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b34dd5bc3bac44f7411e0020df1450a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a9b34dd5bc3bac44f7411e0020df1450a">geodesicDistanceSegmentation</a> (int argc, char **argv, pcl::visualization::PCLVisualizer *visualizer, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a9b34dd5bc3bac44f7411e0020df1450a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment a mesh mostly by using geodesic distances across the mesh. Called by <a class="el" href="segmentation_8h.html#a2ab4959bd79f6778d430f95d649e77a4" title="Function called by main to initiate segmentation of a plant mesh. ">segmentationFromPLY()</a>.  <a href="#a9b34dd5bc3bac44f7411e0020df1450a">More...</a><br/></td></tr>
<tr class="separator:a9b34dd5bc3bac44f7411e0020df1450a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e839a389d04132b03fc509700194b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a38e839a389d04132b03fc509700194b6">refineSegmentation</a> (<a class="el" href="classInputParameters.html">InputParameters</a> inputParams, pcl::PolygonMesh *inputMesh, <a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> *inputSegmentationData, pcl::visualization::PCLVisualizer *visualizer)</td></tr>
<tr class="separator:a38e839a389d04132b03fc509700194b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e6e6698097f15cdf734d81ba449ecc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a01e6e6698097f15cdf734d81ba449ecc">writeIndividualComponentsOfSegmentedMesh</a> (pcl::PolygonMesh inputMesh, pcl::visualization::PCLVisualizer *visualizer)</td></tr>
<tr class="separator:a01e6e6698097f15cdf734d81ba449ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab4959bd79f6778d430f95d649e77a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a2ab4959bd79f6778d430f95d649e77a4">segmentationFromPLY</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a2ab4959bd79f6778d430f95d649e77a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by main to initiate segmentation of a plant mesh.  <a href="#a2ab4959bd79f6778d430f95d649e77a4">More...</a><br/></td></tr>
<tr class="separator:a2ab4959bd79f6778d430f95d649e77a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c302733e16f9b523b175b43960f68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a4b4c302733e16f9b523b175b43960f68">segmentOutPot</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a4b4c302733e16f9b523b175b43960f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment the pot out of a series of registered point clouds.  <a href="#a4b4c302733e16f9b523b175b43960f68">More...</a><br/></td></tr>
<tr class="separator:a4b4c302733e16f9b523b175b43960f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f867c875d00c653b0b6d2f62e31791e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#a6f867c875d00c653b0b6d2f62e31791e">returnLabelOfSupervoxelWithMinimumStemPoint</a> (<a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> inputSegmentationData)</td></tr>
<tr class="separator:a6f867c875d00c653b0b6d2f62e31791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7342aeb7785778015691788eb17a1c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segmentation_8cpp.html#ae7342aeb7785778015691788eb17a1c7">returnLabelOfSupervoxelWithMaximumStemPoint</a> (<a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> inputSegmentationData)</td></tr>
<tr class="separator:ae7342aeb7785778015691788eb17a1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab5a065c9a2e6dc92a1da2023ab564420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::visualization::PointCloudColorHandlerCustom&lt;<a class="el" href="features_8cpp.html#addedd5f094ff6a9309d30e396aa0514b">PointNT</a>&gt; <a class="el" href="features_8cpp.html#ab5a065c9a2e6dc92a1da2023ab564420">ColorHandlerNT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2782f78115ae6b3e2449e6775607a98b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt; <a class="el" href="features_8cpp.html#a2782f78115ae6b3e2449e6775607a98b">ColorHandlerXYZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addedd5f094ff6a9309d30e396aa0514b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pcl::PointNormal <a class="el" href="features_8cpp.html#addedd5f094ff6a9309d30e396aa0514b">PointNT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa33d29c6a70009528ccfc7eca55b2938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcl::PolygonMesh extractMeshFromPolygonMeshGivenPointCloud </td>
          <td>(</td>
          <td class="paramtype">pcl::PolygonMesh&#160;</td>
          <td class="paramname"><em>inputMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>segmentedCloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an input mesh and a point cloud that had been segmented from that mesh. The function should get all of the triangles from the original mesh that would be in the segmented mesh, and output the segmented mesh. </p>
<p>This needs to be the segmented subset of the original cloud</p>
<p>This needs to be the original polygon mesh </p>

</div>
</div>
<a class="anchor" id="a9b34dd5bc3bac44f7411e0020df1450a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int geodesicDistanceSegmentation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visualizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segment a mesh mostly by using geodesic distances across the mesh. Called by <a class="el" href="segmentation_8h.html#a2ab4959bd79f6778d430f95d649e77a4" title="Function called by main to initiate segmentation of a plant mesh. ">segmentationFromPLY()</a>. </p>
<p>This is a third prototype of a segmentation method so that it can be broken and we can get back to the old one if necessary. This time around, we're using an implementation of Dijkstra's Algorithm to find paths over the mesh instead of the geodesic path implementation of Surazhsky et al. "Fast Exact and Approximate Geodesics on Meshes". </p>
<p>Use the stem points identified from machine learning to label the stem.</p>
<p>Partition the cloud into supervoxels that can be used during segmentation</p>
<p>Traverse the supervoxel adjacency graph using Dijkstra's Algorithm as opposed to the geodesic implementation.</p>
<p>First, find the index of the supervoxel that contains the stem point with the minimum Z.</p>
<p>This is the first, rough segmentation. It finds unlabeled points that are most distant to the stem bottom and grows them to identify leaves. This initial rough segmentation gets refined later.</p>
<p>The rough segmentation is complete.</p>
<p>Refine the segmentation based on the leaf tips from the rough segmentation above.</p>
<p>Refine the segmentation.</p>
<p>And finally, we want to recolor the leaves based on their ordering.</p>
<p>Use the stem to align the plant to the z axis.</p>
<p>Write out the final transformed, segmented mesh. </p>

</div>
</div>
<a class="anchor" id="a0fc377dbdd139bb18dd2c64d8815cf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pointsXYZareEqual </td>
          <td>(</td>
          <td class="paramtype">pcl::PointXYZ&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointXYZ&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38e839a389d04132b03fc509700194b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> refineSegmentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PolygonMesh *&#160;</td>
          <td class="paramname"><em>inputMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> *&#160;</td>
          <td class="paramname"><em>inputSegmentationData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visualizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the initial rough segmentation, use the leaf tips that it identified to refine the segmentation. </p>
<p>Here we want to take a phytomer approach to segmentation and grow from the ground up, in a somewhat opposite fashion to the first approach. This requires identifying the right order to process the leaves. Let's loop through the leaf tips and rank them based on their minimum geodesic distance to the stem bottom. Let's also identify the Z coordinate at which their geodesic path is first adjacent to a stem supervoxel.</p>
<p>The Z coordinate at which their geodesic path is first adjacent to a stem supervoxel should be the primary feature for ordering. Leaves below the top of the stem can be ordered by taking the minimum Z coordinate. If the Z coordinates are close, then take the leaf with the minimum geodesic path length. Leaves above the top of the stem (i.e., the whorl), should be ordered by maximum geodesic path length, since the most fully emerged leaves will be the longest.</p>
<p>First, find the index of the supervoxels that contains the stem points with minimum and maximum Z coordinates.</p>
<p>Next, determine how many leaf tips were identified in the initial round, and find the distances for each tip.</p>
<p>This step seems to be one of the most important parts. Doing it based on geodesic distance to the bottom of the stem runs into a problem with the whorl. Maybe we can do it based on the Z coordinate at which the path intercepts a stem point. Maybe the z coordinate at which the path becomes adjacent to a stem point? This should be relatively large Zs for the whorl</p>
<p>We combine two approaches here. 1) Find the Z coordinate of the first leaf supervoxel that is adjacent to a stem supervoxel, and 2) Find the geodesic distance between the leaf tip and the stem base.</p>
<p>Once we have the Z coordinate of the first stem adjacency and the geodesic distance between stem base and leaf tip, we can use that information to order leaves. First, we use the Z coordinate of the first stem adjacency as the primary feature.</p>
<p>That finishes ordering based on Z coordinate of stem adjacency and minimum leaf tip distance. This doesn't work well for leaves above the whorl. For example, if a leaf is part of the whorl, it gives precedence to a young whorl leaf. So, for each supervoxel in the traversal order that has a stemAdjacency greater than the max of the stem, we re-order it based on maximum leaf distance. That is, older leaves will be longer than younger leaves above the stem for a typical plant.</p>
<p>Done finding the ordering that we want to work with the leaves.</p>
<p>Moving on with refinement. Trace the path from each leaf tip to the stem.</p>
<p>We should probably do something like: Label adjacent supervoxels except when one of the adjacent supervoxels is labeled. in which case don't.</p>
<p>Now we fill in the remaining unlabeled supervoxels using a majority rules fill-in. Each iteration, this fills in supervoxels with the most labeled adjacencies based on which color is most abundant in the adjacencies.</p>
<p>Finally, we need to make sure that all of the leaf tips in the original ordering are well represented in the final refined mesh. If they aren't, we should remove the tip and recolor points as necessary. We should also recolor debug color points based on the nearest euclidean color. </p>

</div>
</div>
<a class="anchor" id="ae7342aeb7785778015691788eb17a1c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int returnLabelOfSupervoxelWithMaximumStemPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a>&#160;</td>
          <td class="paramname"><em>inputSegmentationData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should probably get refactored into the supervoxel code? </p>

</div>
</div>
<a class="anchor" id="a6f867c875d00c653b0b6d2f62e31791e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int returnLabelOfSupervoxelWithMinimumStemPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a>&#160;</td>
          <td class="paramname"><em>inputSegmentationData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should probably get refactored into the supervoxel code? </p>

</div>
</div>
<a class="anchor" id="a2ab4959bd79f6778d430f95d649e77a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int segmentationFromPLY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function called by main to initiate segmentation of a plant mesh. </p>
<p>Placeholder until segmentation is worked out. </p>

</div>
</div>
<a class="anchor" id="a3d61e15fa03f8db8dea9f671ab7c9ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> segmentFromLearnedPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>cloudPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::Normal &gt;::Ptr&#160;</td>
          <td class="paramname"><em>cloudNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visualizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Code to segment mesh points based on assignments made during machine learning. </p>
<p>Second version of segmenting stem with learned points so that we can get back to the working original </p>
<p>We need to "reconstruct" the learned cloud using the point values from the input mesh, otherwise we have problems searching it in the tuple map. This assumes the point indices are the same.</p>
<p>Instead of fitting a cylinder, could we region grow the learned points?</p>
<p>Region growing for the stem and inflorescence. </p>
<pre class="fragment">Finished Region growing for the stem and inflorescence.
</pre><p> //////////////////////////////////////////////////</p>

</div>
</div>
<a class="anchor" id="a4b4c302733e16f9b523b175b43960f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int segmentOutPot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segment the pot out of a series of registered point clouds. </p>
<p>This function is currently a monolithic monster. It needs to be refactored.</p>
<p>The premise behind it is:</p>
<p>First, crudely cut out points corresponding to the plant with a pass-through filter. Then, use a combined clound to first find a circle corresponding to the pot; we find a circle instead of a cylinder because the cylinder tends to fit remaining portion of the plant rather than the pot. That circle is used to orient the pot to the Z axis at the origin. Then a cylinder and a plane are used to identify the pot and the dirt, respectively. These are removed, and then region growing is used to get rid of any extra pot points. </p>
<p>Crudely cut off the top part of the plant so that a large circle doesn't mistakenly get fit to the plant A better solution would be to constrain the circle radius in a similar manner to how the cylinder radius can be constrained. However, this doesn't seem to be implemented in PCL right now. So doing this as a temporary fix.</p>
<p>In order to help with identification of the circle, we remove statistical outliers from the pass through filtered cloud.</p>
<p>Finding the circle corresponding to the pot and translating it to the origin aligned with the z axis. </p>
<pre class="fragment">Finished finding the circle corresponding to the pot and translating it to the origin aligned with the z axis.
</pre><p> ///////////////////////////////////////</p>
<p>Getting the rest of the pot out using RANSAC</p>
<p>Instead of estimating the cylinder model, we manually set it to be at the origin and based on the circle radius. </p>
<pre class="fragment">Finished getting the rest of the pot out using RANSAC
</pre><p> ///////////////////////////////////////</p>
<p>Need to add another input parameter value for the select within distance here.</p>
<p>Region growing. </p>
<pre class="fragment">Finished Region growing.
</pre><p> //////////////////////////////////////////////////</p>

</div>
</div>
<a class="anchor" id="acb9b302edc2b330924a76979500c03eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPlantSegmentationDataContainer.html">PlantSegmentationDataContainer</a> segmentStemWithRANSAC </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>cloudPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::Normal &gt;::Ptr&#160;</td>
          <td class="paramname"><em>cloudNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01e6e6698097f15cdf734d81ba449ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeIndividualComponentsOfSegmentedMesh </td>
          <td>(</td>
          <td class="paramtype">pcl::PolygonMesh&#160;</td>
          <td class="paramname"><em>inputMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visualizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2016 10:28:18 for Sorghum Reconstruction and Phenotyping by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
