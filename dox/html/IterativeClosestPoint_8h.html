<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Sorghum Reconstruction and Phenotyping: IterativeClosestPoint.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sorghum Reconstruction and Phenotyping
   &#160;<span id="projectnumber">0.02</span>
   </div>
   <div id="projectbrief">Image-based plant phenotyping</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IterativeClosestPoint.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;pcl/registration/registration.h&gt;</code><br/>
<code>#include &lt;pcl/registration/icp.h&gt;</code><br/>
<code>#include &lt;pcl/registration/icp_nl.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="inputParams_8h_source.html">inputParams.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="loggingHelper_8h_source.html">loggingHelper.h</a>&quot;</code><br/>
</div>
<p><a href="IterativeClosestPoint_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeClosestPointNonLinear__Exposed.html">IterativeClosestPointNonLinear_Exposed&lt; PointSource, PointTarget, Scalar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a mock class with the sole purpose of accessing a protected member of a class it inherits from.  <a href="classIterativeClosestPointNonLinear__Exposed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54ecf78abe3f9eefb5b7ec1d3295e641"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a54ecf78abe3f9eefb5b7ec1d3295e641">registerPointCloudsICP_pairwise</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a54ecf78abe3f9eefb5b7ec1d3295e641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise iterative closest point for all input clouds in the order they are provided.  <a href="#a54ecf78abe3f9eefb5b7ec1d3295e641">More...</a><br/></td></tr>
<tr class="separator:a54ecf78abe3f9eefb5b7ec1d3295e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580a19087a295cbd8e44bdbf7634aa9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a580a19087a295cbd8e44bdbf7634aa9f">registerPointCloudsICP_oneAgainstGlobal</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a580a19087a295cbd8e44bdbf7634aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs pairwise iterative closest point for all input clouds in the order they are provided. After finishing a pair, the pair is added to the global cloud. The global cloud is used for the next pairwise iteration.  <a href="#a580a19087a295cbd8e44bdbf7634aa9f">More...</a><br/></td></tr>
<tr class="separator:a580a19087a295cbd8e44bdbf7634aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bbbedcab6ea50b6336ba7cea992fbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a68bbbedcab6ea50b6336ba7cea992fbe">registerPointCloudsICP_refinement</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="memdesc:a68bbbedcab6ea50b6336ba7cea992fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses statistical outlier removal to filter the cloud, then performs pairwise iterative closest point for all input clouds in the order they are provided. After finishing a pair, the pair is added to the global cloud. The global cloud is used for the next pairwise iteration. This is nearly identical to the oneAgainstGlobal ICP.  <a href="#a68bbbedcab6ea50b6336ba7cea992fbe">More...</a><br/></td></tr>
<tr class="separator:a68bbbedcab6ea50b6336ba7cea992fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa720360aa2b366e9d226f0b0f09d81af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#aa720360aa2b366e9d226f0b0f09d81af">registerKinectFusionPLYs</a> (int argc, char **argv, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:aa720360aa2b366e9d226f0b0f09d81af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b426ba508182ca15bba314aebe6442"><td class="memItemLeft" align="right" valign="top">pcl::CorrespondencesPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a55b426ba508182ca15bba314aebe6442">registerPointCloudsICPAndReturnCorrespondences</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputSourceCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputTargetCloud, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a55b426ba508182ca15bba314aebe6442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad913fa3484ef5f3db509492e9f1d078e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#ad913fa3484ef5f3db509492e9f1d078e">registerLSystemICP</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputSourceCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputTargetCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputSourceTransformedToTarget, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:ad913fa3484ef5f3db509492e9f1d078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347472dc7d5c1a5e71f1c46a8d42b762"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a347472dc7d5c1a5e71f1c46a8d42b762">registerLSystemICPAndReturnTranslationMatrix</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputSourceCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputTargetCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputSourceTransformedToTarget, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a347472dc7d5c1a5e71f1c46a8d42b762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea831ca107b73142e30eee25fa95a36"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a1ea831ca107b73142e30eee25fa95a36">registerLSystemICPAndReturnFitness</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputSourceCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputTargetCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputSourceTransformedToTarget, pcl::visualization::PCLVisualizer *visu, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a1ea831ca107b73142e30eee25fa95a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276ef486ac156cff9bc59dd5fe057886"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="IterativeClosestPoint_8h.html#a276ef486ac156cff9bc59dd5fe057886">registerLSystemICPAndReturnFitness_ForParallelCalling</a> (pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputSourceCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr inputTargetCloud, pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr outputSourceTransformedToTarget, <a class="el" href="classInputParameters.html">InputParameters</a> inputParams)</td></tr>
<tr class="separator:a276ef486ac156cff9bc59dd5fe057886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa720360aa2b366e9d226f0b0f09d81af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int registerKinectFusionPLYs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Here we downsample the plant to speed up registration.</p>
<p>Here we crudely cut off the pot to prevent it from causing problems during registration of the plant.</p>
<p>If debugging level is set to high, visualize each individual transformation. There is tremendous duplication of code here between the debugging level if statment cases(and all throughout the ICP code). Consider refactoring.</p>
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation.</p>
<p>Else if the debugging level is not high, try to do it more quickly. We should probably still reduce max correspondence distance as we go.</p>
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
<a class="anchor" id="ad913fa3484ef5f3db509492e9f1d078e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int registerLSystemICP </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputSourceCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputTargetCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputSourceTransformedToTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
<a class="anchor" id="a1ea831ca107b73142e30eee25fa95a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float registerLSystemICPAndReturnFitness </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputSourceCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputTargetCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputSourceTransformedToTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
<a class="anchor" id="a276ef486ac156cff9bc59dd5fe057886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float registerLSystemICPAndReturnFitness_ForParallelCalling </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputSourceCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputTargetCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputSourceTransformedToTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a347472dc7d5c1a5e71f1c46a8d42b762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4f registerLSystemICPAndReturnTranslationMatrix </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputSourceCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputTargetCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>outputSourceTransformedToTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
<a class="anchor" id="a580a19087a295cbd8e44bdbf7634aa9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int registerPointCloudsICP_oneAgainstGlobal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise iterative closest point for all input clouds in the order they are provided. After finishing a pair, the pair is added to the global cloud. The global cloud is used for the next pairwise iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>the value of argc at runtime decremented by 2 (to account for removing the program name and the input .xml file) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>the argv given at runtime shifted by two indices (to account for removing the program name and the input .xml file). argv will have the called processing option in argv[0], and the remaining indices are the point clouds in the order to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputParams</td><td>the <a class="el" href="classInputParameters.html" title="Container that holds all input parameters so that they can be passed to processing functions...">InputParameters</a> object that contains values to be used, read in from the input .xml file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan McCormick</dd></dl>
<p>This one against global ICP is helpful to refine the alignment after an initial round of the pairwise. Much of this code originates from the PCL tutorial at <a href="http://pointclouds.org/documentation/tutorials/pairwise_incremental_registration.php">http://pointclouds.org/documentation/tutorials/pairwise_incremental_registration.php</a> Much of the code is duplicated from the pairwise registration.</p>
<p>We take the time to use this one after the initial pairwise since the initial pairwise can be off by a few centimeters which has potential to mess things up when trying to segment the pot out. </p>
<p>Here we crudely cut off the pot to prevent it from causing problems during registration of the plant.</p>
<p>If debugging level is set to high, visualize each individual transformation. There is tremendous duplication of code here between the debugging level if statment cases(and all throughout the ICP code). Consider refactoring.</p>
<p>Else if the debugging level is not high, try to do it more quickly. We should probably still reduce max correspondence distance as we go. </p>

</div>
</div>
<a class="anchor" id="a54ecf78abe3f9eefb5b7ec1d3295e641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int registerPointCloudsICP_pairwise </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs pairwise iterative closest point for all input clouds in the order they are provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>the value of argc at runtime decremented by 2 (to account for removing the program name and the input .xml file) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>the argv given at runtime shifted by two indices (to account for removing the program name and the input .xml file). argv will have the called processing option in argv[0], and the remaining indices are the point clouds in the order to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputParams</td><td>the <a class="el" href="classInputParameters.html" title="Container that holds all input parameters so that they can be passed to processing functions...">InputParameters</a> object that contains values to be used, read in from the input .xml file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan McCormick</dd></dl>
<p>Incrementally registers a group of pointclouds. Each pair is registered, and a global transform is updated to put all clouds into the same reference frame as the first. Much of this code originates from the PCL tutorial at <a href="http://pointclouds.org/documentation/tutorials/pairwise_incremental_registration.php">http://pointclouds.org/documentation/tutorials/pairwise_incremental_registration.php</a></p>
<p>This is useful for a "coarse" registration to get each cloud in roughly the same frame. Jumping straight to a global ICP seems to often provide poor results, whereas using a coarse pairwise registration first has worked well.</p>
<p>This will also try a RANSAC approach to registration if the ICP fitness score is too large.</p>
<p>Relevant sets of input parameters: <a class="el" href="classPassThroughFilterParameters.html" title="Parameters obtained from the input .xml file for an x, y, z pass through filter with which point clou...">PassThroughFilterParameters</a> to crudely remove parts of the image that would ruin ICP registration (e.g., the pot). <a class="el" href="classVoxelGridFilterParameters.html" title="Parameters obtained from the input .xml file used to downsample a cloud using a voxel grid...">VoxelGridFilterParameters</a> to downsample the clouds and speed up registration. <a class="el" href="classIterativeClosestPointParameters.html" title="Parameters obtained from the input .xml file used to perform iterative closest point registration...">IterativeClosestPointParameters</a> to define ICP parameters SampleConsensusPRerejectiveParameters in case ICP fails to be underneath a fitness threshold specified in the configuration. <a class="el" href="classDebuggingParameters.html" title="Parameters obtained from the input .xml file used to define the debugging level. Higher levels provid...">DebuggingParameters</a> to affect the verbosity of output and to choose whether or not to display ICP updates in the visualizer. </p>
<p>Here we downsample the plant to speed up registration.</p>
<p>Here we crudely cut off the pot to prevent it from causing problems during registration of the plant.</p>
<p>If debugging level is set to high, visualize each individual transformation. There is tremendous duplication of code here between the debugging level if statment cases(and all throughout the ICP code). Consider refactoring.</p>
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation.</p>
<p>Else if the debugging level is not high, try to do it more quickly. We should probably still reduce max correspondence distance as we go.</p>
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
<a class="anchor" id="a68bbbedcab6ea50b6336ba7cea992fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int registerPointCloudsICP_refinement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses statistical outlier removal to filter the cloud, then performs pairwise iterative closest point for all input clouds in the order they are provided. After finishing a pair, the pair is added to the global cloud. The global cloud is used for the next pairwise iteration. This is nearly identical to the oneAgainstGlobal ICP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>the value of argc at runtime decremented by 2 (to account for removing the program name and the input .xml file) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>the argv given at runtime shifted by two indices (to account for removing the program name and the input .xml file). argv will have the called processing option in argv[0], and the remaining indices are the point clouds in the order to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputParams</td><td>the <a class="el" href="classInputParameters.html" title="Container that holds all input parameters so that they can be passed to processing functions...">InputParameters</a> object that contains values to be used, read in from the input .xml file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan McCormick</dd></dl>
<p>Nearly identical to the oneAgainstGlobal, except adds a step to remove statistical outliers. The idea here is that, prior to removing the pot from the images, the high density of points relative to the plant skews statistical outlier removal. Additionally, removing outliers from the combined point cloud doesn't prevent the noise from harming registration. So, this special step here is used to remove outliers and then register AFTER the pot has been removed. </p>
<p>If debugging level is set to high, visualize each individual transformation. There is tremendous duplication of code here between the debugging level if statment cases(and all throughout the ICP code). Consider refactoring.</p>
<p>Else if the debugging level is not high, try to do it more quickly. We should probably still reduce max correspondence distance as we go. </p>

</div>
</div>
<a class="anchor" id="a55b426ba508182ca15bba314aebe6442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcl::CorrespondencesPtr registerPointCloudsICPAndReturnCorrespondences </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputSourceCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZ &gt;::Ptr&#160;</td>
          <td class="paramname"><em>inputTargetCloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::visualization::PCLVisualizer *&#160;</td>
          <td class="paramname"><em>visu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td>
          <td class="paramname"><em>inputParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes ICP isn't sufficient. Let's try adding a check based on fitness score, and send the pair to Prerejective RANSAC to get a better transformation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 15 2016 10:28:18 for Sorghum Reconstruction and Phenotyping by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
